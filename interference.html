<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Interference Phenomenon</title>
  <script src="https://cdn.jsdelivr.net/npm/p5@1.4.0/lib/p5.min.js"></script>
</head>
<body>
  <script>
    let leftWallX = 100;
    let rightWallX = 475; // reduced distance by 25%
    let wallHeight = 400;

    let slit1Y, slit2Y;
    let slitSpacing = 80;
    let waveFrequency = 0.2; // radians per pixel
    let waveAmplitude = 7.5; // increased by 50%

    let phaseCounter = 0;
    let phaseSteps = 100;
    let phaseShift = 0;

    let maxPoints = [];
    let minPoints = [];

    // Relative positions for graphs and marks
    let graphOffset = 50;
    let graph1X, graph2X, graph3X, markEndX;

    function setup() {
      createCanvas(950, 500);
      slit1Y = height / 2 - slitSpacing / 2;
      slit2Y = height / 2 + slitSpacing / 2;
      phaseCounter = 0;
      phaseShift = 0;

      graph1X = rightWallX + graphOffset;
      graph2X = graph1X + 30;
      graph3X = graph2X + 30;
      markEndX = graph3X + 20;

      calculateStationaryMarks();
    }

    function calculateStationaryMarks() {
      let dx = rightWallX - leftWallX;
      let combinedAmplitudes = [];

      for (let y = 50; y <= 450; y++) {
        let dy1 = y - slit1Y;
        let d1 = sqrt(dx * dx + dy1 * dy1);
        let phase1 = d1 * waveFrequency;

        let dy2 = y - slit2Y;
        let d2 = sqrt(dx * dx + dy2 * dy2);
        let phase2 = d2 * waveFrequency;

        let realSum = cos(phase1) + cos(phase2);
        let imagSum = sin(phase1) + sin(phase2);

        let amplitude = sqrt(realSum * realSum + imagSum * imagSum) * waveAmplitude;
        combinedAmplitudes.push({ y: y, amplitude: amplitude });
      }

      for (let i = 1; i < combinedAmplitudes.length - 1; i++) {
        let prev = combinedAmplitudes[i - 1].amplitude;
        let curr = combinedAmplitudes[i].amplitude;
        let next = combinedAmplitudes[i + 1].amplitude;

        if (curr > prev && curr > next) {
          maxPoints.push(combinedAmplitudes[i].y);
        }
        if (curr < prev && curr < next) {
          minPoints.push(combinedAmplitudes[i].y);
        }
      }
    }

    function draw() {
      background(255);

      phaseCounter = (phaseCounter + 1) % phaseSteps;
      phaseShift = phaseCounter * 4 * PI / phaseSteps;

      stroke(0);
      fill(200);
      rect(leftWallX - 10, 50, 20, wallHeight);
      rect(rightWallX - 10, 50, 20, wallHeight);

      fill(0);
      ellipse(leftWallX, slit1Y, 8, 8);
      ellipse(leftWallX, slit2Y, 8, 8);

      let intersectionY = constrain(mouseY, 50, wallHeight + 50);

      drawWaveRay(leftWallX, slit1Y, rightWallX, intersectionY);
      drawWaveRay(leftWallX, slit2Y, rightWallX, intersectionY);

      noStroke();
      fill(50, 50, 200);
      ellipse(rightWallX, intersectionY, 10, 10);

      drawAmplitudeGraph(slit1Y, graph1X);
      drawAmplitudeGraph(slit2Y, graph2X);
      drawCombinedGraph(slit1Y, slit2Y, graph3X);

      stroke(0);
      line(graph1X, 50, graph1X, 450);
      line(graph2X, 50, graph2X, 450);
      line(graph3X, 50, graph3X, 450);

      drawStationaryMarks();
    }

    function drawStationaryMarks() {
      drawingContext.setLineDash([2, 4]);
      strokeWeight(0.5);
      for (let i = 0; i < maxPoints.length; i++) {
        stroke(255, 100, 100);
        line(rightWallX, maxPoints[i], markEndX, maxPoints[i]);
      }
      for (let i = 0; i < minPoints.length; i++) {
        stroke(100);
        line(rightWallX, minPoints[i], markEndX, minPoints[i]);
      }
      drawingContext.setLineDash([]);
      strokeWeight(1);
    }

    function drawWaveRay(x1, y1, x2, y2) {
      noFill();
      let dx = x2 - x1;
      let dy = y2 - y1;
      let length = dist(x1, y1, x2, y2);
      let angle = atan2(dy, dx);

      let cycleLength = TWO_PI / waveFrequency;
      let offsetShift = (-phaseShift / waveFrequency) % cycleLength;
      if (offsetShift < 0) offsetShift += cycleLength;

      let firstCycleStart = -offsetShift;
      let numCycles = ceil((length - firstCycleStart) / cycleLength);
      let baseCycleOffset = floor(-phaseShift / TWO_PI);

      for (let cycle = 0; cycle < numCycles; cycle++) {
        let startLength = firstCycleStart + cycle * cycleLength;
        let endLength = min(startLength + cycleLength, length);
        if (startLength < 0) startLength = 0;
        if (endLength <= startLength) continue;

        let steps = int((endLength - startLength) / 2);

        let colorCycleIndex = baseCycleOffset + cycle;
        if (colorCycleIndex % 2 === 0) {
          stroke(0, 150, 136);
        } else {
          stroke(255, 193, 7);
        }

        beginShape();
        for (let i = 0; i <= steps; i++) {
          let d = startLength + (i / steps) * (endLength - startLength);
          let t = d / length;
          let x = lerp(x1, x2, t);
          let y = lerp(y1, y2, t);
          let offset = sin(d * waveFrequency - phaseShift) * waveAmplitude;
          let px = x + offset * cos(angle + HALF_PI);
          let py = y + offset * sin(angle + HALF_PI);
          vertex(px, py);
        }
        endShape();
      }
    }

    function drawAmplitudeGraph(slitY, graphX) {
      let dx = rightWallX - leftWallX;
      let cycleLength = TWO_PI / waveFrequency;
      let offsetShift = (-phaseShift / waveFrequency) % cycleLength;
      if (offsetShift < 0) offsetShift += cycleLength;
      let baseCycleOffset = floor(-phaseShift / TWO_PI);

      for (let y = 50; y <= 450; y += 1) {
        let dy = y - slitY;
        let d = sqrt(dx * dx + dy * dy);
        let amplitude = sin(d * waveFrequency - phaseShift) * waveAmplitude;
        let cycleIndex = baseCycleOffset + floor((d + offsetShift) / cycleLength);

        if ((cycleIndex % 2) === 0) {
          stroke(0, 150, 136);
        } else {
          stroke(255, 193, 7);
        }
        point(graphX + amplitude, y);
      }
    }

    function drawCombinedGraph(slit1Y, slit2Y, graphX) {
      let dx = rightWallX - leftWallX;
      for (let y = 50; y <= 450; y += 1) {
        let dy1 = y - slit1Y;
        let d1 = sqrt(dx * dx + dy1 * dy1);
        let amp1 = sin(d1 * waveFrequency - phaseShift) * waveAmplitude;

        let dy2 = y - slit2Y;
        let d2 = sqrt(dx * dx + dy2 * dy2);
        let amp2 = sin(d2 * waveFrequency - phaseShift) * waveAmplitude;

        let combined = amp1 + amp2;

        let intensity = map(abs(combined), 0, waveAmplitude * 2, 100, 255);
        stroke(intensity, 0, 0);
        point(graphX + combined, y);
      }
    }
  </script>
</body>
</html>
