<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Interference Phenomenon</title>
  <script src="https://cdn.jsdelivr.net/npm/p5@1.4.0/lib/p5.min.js"></script>
</head>
<body>
  <div id="canvas-container"></div>

  <script>
    let canvasWidth = 1500;
    let canvasHeight = 1000;

    let leftWallX = 100;
    let rightWallX = 475;
    let wallTopY = 0.1 * canvasHeight;
    let wallHeight = 0.8 * canvasHeight;

    let slit1Y, slit2Y;
    let slitSpacing = 80;
    let waveFrequency = 0.2;
    let waveAmplitude = 7.5;

    let phaseCounter = 0;
    let phaseSteps = 100;
    let phaseShift = 0;

    let maxPoints = [];
    let minPoints = [];

    let graphOffsetRatio = 0.05;
    let graphSpacingRatio = 0.03;
    let markEndRatio = 0.02;
    let graph1X, graph2X, graph3X, markEndX;

    function setup() {
      let cnv = createCanvas(canvasWidth, canvasHeight);
      cnv.parent('canvas-container');
      calculateDerivedValues();
      calculateStationaryMarks();
    }

    function calculateDerivedValues() {
      slit1Y = height / 2 - slitSpacing / 2;
      slit2Y = height / 2 + slitSpacing / 2;
      graph1X = rightWallX + graphOffsetRatio * canvasWidth;
      graph2X = graph1X + graphSpacingRatio * canvasWidth;
      graph3X = graph2X + graphSpacingRatio * canvasWidth;
      markEndX = graph3X + markEndRatio * canvasWidth;
    }

    function calculateStationaryMarks() {
      maxPoints = [];
      minPoints = [];
      let dx = rightWallX - leftWallX;
      let combinedAmplitudes = [];
      for (let y = wallTopY; y <= wallTopY + wallHeight; y++) {
        let dy1 = y - slit1Y;
        let d1 = sqrt(dx * dx + dy1 * dy1);
        let phase1 = d1 * waveFrequency;
        let dy2 = y - slit2Y;
        let d2 = sqrt(dx * dx + dy2 * dy2);
        let phase2 = d2 * waveFrequency;
        let realSum = cos(phase1) + cos(phase2);
        let imagSum = sin(phase1) + sin(phase2);
        let amplitude = sqrt(realSum * realSum + imagSum * imagSum) * waveAmplitude;
        combinedAmplitudes.push({ y: y, amplitude: amplitude });
      }
      for (let i = 1; i < combinedAmplitudes.length - 1; i++) {
        let prev = combinedAmplitudes[i - 1].amplitude;
        let curr = combinedAmplitudes[i].amplitude;
        let next = combinedAmplitudes[i + 1].amplitude;
        if (curr > prev && curr > next) {
          maxPoints.push(combinedAmplitudes[i].y);
        }
        if (curr < prev && curr < next) {
          minPoints.push(combinedAmplitudes[i].y);
        }
      }
    }

    function drawWaveRay(x1, y1, x2, y2) {
      noFill();
      let dx = x2 - x1;
      let dy = y2 - y1;
      let length = dist(x1, y1, x2, y2);
      let angle = atan2(dy, dx);
      let cycleLength = TWO_PI / waveFrequency;
      let offsetShift = (-phaseShift / waveFrequency) % cycleLength;
      if (offsetShift < 0) offsetShift += cycleLength;
      let firstCycleStart = -offsetShift;
      let numCycles = ceil((length - firstCycleStart) / cycleLength);
      let baseCycleOffset = floor(-phaseShift / TWO_PI);
      for (let cycle = 0; cycle < numCycles; cycle++) {
        let startLength = firstCycleStart + cycle * cycleLength;
        let endLength = min(startLength + cycleLength, length);
        if (startLength < 0) startLength = 0;
        if (endLength <= startLength) continue;
        let steps = int((endLength - startLength) / 2);
        let colorCycleIndex = baseCycleOffset + cycle;
        if (colorCycleIndex % 2 === 0) {
          stroke(0, 150, 136);
        } else {
          stroke(255, 193, 7);
        }
        beginShape();
        for (let i = 0; i <= steps; i++) {
          let d = startLength + (i / steps) * (endLength - startLength);
          let t = d / length;
          let x = lerp(x1, x2, t);
          let y = lerp(y1, y2, t);
          let offset = sin(d * waveFrequency - phaseShift) * waveAmplitude;
          let px = x + offset * cos(angle + HALF_PI);
          let py = y + offset * sin(angle + HALF_PI);
          vertex(px, py);
        }
        endShape();
      }
    }

    function drawAmplitudeGraph(slitY, graphX) {
      let dx = rightWallX - leftWallX;
      let cycleLength = TWO_PI / waveFrequency;
      let offsetShift = (-phaseShift / waveFrequency) % cycleLength;
      if (offsetShift < 0) offsetShift += cycleLength;
      let baseCycleOffset = floor(-phaseShift / TWO_PI);
      for (let y = wallTopY; y <= wallTopY + wallHeight; y += 1) {
        let dy = y - slitY;
        let d = sqrt(dx * dx + dy * dy);
        let amplitude = sin(d * waveFrequency - phaseShift) * waveAmplitude;
        let cycleIndex = baseCycleOffset + floor((d + offsetShift) / cycleLength);
        if ((cycleIndex % 2) === 0) {
          stroke(0, 150, 136);
        } else {
          stroke(255, 193, 7);
        }
        point(graphX + amplitude, y);
      }
    }

    function drawCombinedGraph(slit1Y, slit2Y, graphX) {
      let dx = rightWallX - leftWallX;
      for (let y = wallTopY; y <= wallTopY + wallHeight; y += 1) {
        let dy1 = y - slit1Y;
        let d1 = sqrt(dx * dx + dy1 * dy1);
        let amp1 = sin(d1 * waveFrequency - phaseShift) * waveAmplitude;
        let dy2 = y - slit2Y;
        let d2 = sqrt(dx * dx + dy2 * dy2);
        let amp2 = sin(d2 * waveFrequency - phaseShift) * waveAmplitude;
        let combined = amp1 + amp2;
        let intensity = map(abs(combined), 0, waveAmplitude * 2, 100, 255);
        stroke(intensity, 0, 0);
        point(graphX + combined, y);
      }
    }

    function drawStationaryMarks() {
      drawingContext.setLineDash([2, 4]);
      strokeWeight(0.5);
      for (let i = 0; i < maxPoints.length; i++) {
        stroke(255, 100, 100);
        line(rightWallX, maxPoints[i], markEndX, maxPoints[i]);
      }
      for (let i = 0; i < minPoints.length; i++) {
        stroke(100);
        line(rightWallX, minPoints[i], markEndX, minPoints[i]);
      }
      drawingContext.setLineDash([]);
      strokeWeight(1);
    }

    function draw() {
      background(255);
      phaseCounter = (phaseCounter + 1) % phaseSteps;
      phaseShift = phaseCounter * 4 * PI / phaseSteps;
      stroke(0);
      fill(200);
      rect(leftWallX - 10, wallTopY, 20, wallHeight);
      rect(rightWallX - 10, wallTopY, 20, wallHeight);
      fill(0);
      ellipse(leftWallX, slit1Y, 8, 8);
      ellipse(leftWallX, slit2Y, 8, 8);
      let intersectionY = constrain(mouseY, wallTopY, wallTopY + wallHeight);
      drawWaveRay(leftWallX, slit1Y, rightWallX, intersectionY);
      drawWaveRay(leftWallX, slit2Y, rightWallX, intersectionY);
      noStroke();
      fill(50, 50, 200);
      ellipse(rightWallX, intersectionY, 10, 10);
      drawAmplitudeGraph(slit1Y, graph1X);
      drawAmplitudeGraph(slit2Y, graph2X);
      drawCombinedGraph(slit1Y, slit2Y, graph3X);
      stroke(0);
      line(graph1X, wallTopY, graph1X, wallTopY + wallHeight);
      line(graph2X, wallTopY, graph2X, wallTopY + wallHeight);
      line(graph3X, wallTopY, graph3X, wallTopY + wallHeight);
      drawStationaryMarks();
    }
  </script>

  <div style="margin-top: 20px;">
    <label for="wallDistance">Distance Between Walls:</label>
    <input type="range" id="wallDistance" name="wallDistance" min="300" max="700" value="475">
    <span id="wallDistanceValue">475</span>
    <br>
    <label for="slitSpacing">Separation Between Holes:</label>
    <input type="range" id="slitSpacing" name="slitSpacing" min="20" max="200" value="80">
    <span id="slitSpacingValue">80</span>
    <br>
    <label for="waveAmplitude">Wave Amplitude:</label>
    <input type="range" id="waveAmplitude" name="waveAmplitude" min="1" max="20" value="7.5" step="0.1">
    <span id="waveAmplitudeValue">7.5</span>
    <br>
    <label for="waveFrequency">Wave Frequency (2π/λ):</label>
    <input type="range" id="waveFrequency" name="waveFrequency" min="0.05" max="1" value="0.2" step="0.01">
    <span id="waveFrequencyValue">0.2</span>
  </div>
</body>
</html>
